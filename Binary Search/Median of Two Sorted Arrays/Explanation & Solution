# Median of Two Sorted Arrays

**LeetCode Link**: [Median of Two Sorted Arrays](https://leetcode.com/problems/median-of-two-sorted-arrays/)

## Difficulty
Hard

## Description
Given two sorted arrays `nums1` and `nums2` of size `m` and `n` respectively, return the median of the two sorted arrays.

The overall run time complexity should be `O(log (m+n))`.

### Constraints
- `nums1.length == m`
- `nums2.length == n`
- `0 <= m <= 1000`
- `0 <= n <= 1000`
- `1 <= m + n <= 2000`
- `-10⁶ <= nums1[i], nums2[i] <= 10⁶`

---

## Example

**Input:**
nums1 = [1, 3]
nums2 = [2]

makefile
Copy
Edit

**Output:**
2.0

yaml
Copy
Edit

**Explanation:**
The combined array is [1, 2, 3] and the median is 2.

---

**Input:**
nums1 = [1, 2]
nums2 = [3, 4]

makefile
Copy
Edit

**Output:**
2.5

sql
Copy
Edit

**Explanation:**
The combined array is [1, 2, 3, 4] and the median is (2 + 3) / 2 = 2.5

---

## Approach

- Use binary search on the smaller array to partition both arrays.
- Ensure elements on the left of both partitions are less than or equal to the elements on the right.
- Calculate the median based on the max of left parts and min of right parts.

### Why Binary Search?
To achieve `O(log(min(m,n)))` time complexity, binary search is applied to the shorter array. We move the partition until the correct condition is met:
maxLeft1 <= minRight2 && maxLeft2 <= minRight1

pgsql
Copy
Edit

---

## Time and Space Complexity

- **Time Complexity:** `O(log(min(m, n)))`  
- **Space Complexity:** `O(1)`

---

## Code (Java)
```java
class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        if (nums1.length > nums2.length) {
            return findMedianSortedArrays(nums2, nums1);
        }

        int m = nums1.length;
        int n = nums2.length;
        int left = 0;
        int right = m;

        while (left <= right) {
            int i = (left + right) / 2;
            int j = (m + n + 1) / 2 - i;

            int maxLeft1 = (i == 0) ? Integer.MIN_VALUE : nums1[i - 1];
            int minRight1 = (i == m) ? Integer.MAX_VALUE : nums1[i];

            int maxLeft2 = (j == 0) ? Integer.MIN_VALUE : nums2[j - 1];
            int minRight2 = (j == n) ? Integer.MAX_VALUE : nums2[j];

            if (maxLeft1 <= minRight2 && maxLeft2 <= minRight1) {
                if ((m + n) % 2 == 0) {
                    return (Math.max(maxLeft1, maxLeft2) + Math.min(minRight1, minRight2)) / 2.0;
                } else {
                    return (double)Math.max(maxLeft1, maxLeft2);
                }
            } else if (maxLeft1 > minRight2) {
                right = i - 1;
            } else {
                left = i + 1;
            }
        }

        throw new IllegalArgumentException("Input arrays are not sorted properly.");
    }
}
