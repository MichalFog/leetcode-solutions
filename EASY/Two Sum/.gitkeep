# **Explanation: Two Sum**

## **Problem:** [Two Sum - LeetCode](https://leetcode.com/problems/two-sum/)

### **Difficulty Level:** Easy

---

## **Description**  
Given an array of integers `nums` and an integer `target`,  
return indices of the two numbers such that they add up to `target`.  

- You may assume that each input would have exactly one solution.
- You may not use the same element twice.
- You can return the answer in any order.

---

## **Example**

**Input:** `nums = [2,7,11,15]`, `target = 9`  
**Output:** `[0,1]`  
**Explanation:**  
nums[0] + nums[1] = 2 + 7 = 9

yaml
Copy
Edit

**Input:** `nums = [3,2,4]`, `target = 6`  
**Output:** `[1,2]`  

**Input:** `nums = [3,3]`, `target = 6`  
**Output:** `[0,1]`  

---

## **Approach**

We use a **HashMap** to store the elements we've already seen along with their indices:

1. Iterate over the array with index `i`.
2. For each element `nums[i]`, calculate the complement: `target - nums[i]`.
3. Check if this complement already exists in the map:
   - If yes, return the current index `i` and the index of the complement.
4. If not, store `nums[i]` with its index in the map.

This ensures we find the solution in a single pass.

---

## **Time Complexity**
- **O(n)** where `n` is the number of elements in `nums`.

## **Space Complexity**
- **O(n)** for the HashMap that stores seen elements.

---

## **Code**

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        HashMap<Integer, Integer> hash = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            int num = target - nums[i];
            if (hash.containsKey(num)) {
                return new int[] { hash.get(num), i };
            }
            hash.put(nums[i], i);
        }
        return null;
    }
}
