# **Explanation: Longest Substring Without Repeating Characters**

## **Problem:** [Longest Substring Without Repeating Characters - LeetCode](https://leetcode.com/problems/longest-substring-without-repeating-characters/)

### **Difficulty Level:** Medium

---

## **Description**  
Given a string `s`, find the length of the **longest substring** without repeating characters.

---

## **Example**

**Input:**  
s = "abcabcbb"

makefile
Copy
Edit
**Output:**  
3

yaml
Copy
Edit
**Explanation:**  
The answer is `"abc"`, with the length of 3.

---

**Input:**  
s = "bbbbb"

makefile
Copy
Edit
**Output:**  
1

yaml
Copy
Edit
**Explanation:**  
The answer is `"b"`.

---

**Input:**  
s = "pwwkew"

makefile
Copy
Edit
**Output:**  
3

markdown
Copy
Edit
**Explanation:**  
The answer is `"wke"`, with the length of 3.  
Note that the answer must be a **substring**, not a subsequence.

---

## **Approach**

We use the **sliding window** technique with a `HashSet` to track seen characters:

1. Initialize:
   - A `left` pointer at the start of the window.
   - A `right` pointer iterating through the string.
   - A `HashSet<Character>` to store characters in the current window.
   - A variable `maxLength` to track the maximum window size without duplicates.

2. For each character at index `right`:
   - If it's already in the `seen` set, shrink the window from the left until it's removed.
   - Add the current character to the set.
   - Update `maxLength` if the current window is longer than previous.

This ensures that the window always contains **unique characters**.

---

## **Time Complexity**
- **O(n)**, where `n` is the length of the string.
  - Each character is visited at most twice (once by `right`, once by `left`).

## **Space Complexity**
- **O(min(n, m))**, where `n` is the length of the string and `m` is the size of the character set (e.g., 26 for lowercase English).

---

## **Code**

```java
class Solution {
    public static int lengthOfLongestSubstring(String s) {
        Set<Character> seen = new HashSet<>();
        int left = 0, maxLength = 0;

        for (int right = 0; right < s.length(); right++) {
            char currentChar = s.charAt(right);

            while (seen.contains(currentChar)) {
                seen.remove(s.charAt(left));
                left++;
            }

            seen.add(currentChar);
            maxLength = Math.max(maxLength, right - left + 1);
        }

        return maxLength;
    }
}
